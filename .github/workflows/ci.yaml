name: CI Pipeline

on:
  pull_request:
    branches:
      - main

# Define environment variables to store repetitive values
env:
  GITHUB_WORKSPACE: ${{ github.workspace }}
  DEFECTDOJO_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
  DEFECTDOJO_URL: ${{ secrets.DEFECTDOJO_URL }}
  DEFECTDOJO_ENGAGEMENT_ID: ${{ secrets.DEFECTDOJO_ENGAGEMENT_ID }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

defaults:
  run:
    shell: bash

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v2

    # Set up Go environment
    - name: Set up Go environment
      uses: actions/setup-go@v4
      with:
        go-version: '1.20'

    # Ensure go.mod exists
    - name: Ensure go.mod exists
      run: |
        cd codegen
        if [ ! -f go.mod ]; then
          go mod init example.com/m
        fi

    # Install dependencies
    - name: Install dependencies
      run: cd codegen && go mod tidy

    # Run Go tests
    - name: Run Go tests
      run: cd codegen && go test -v ./...

  gitleaks:
    runs-on: ubuntu-latest

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v2

    # Run Gitleaks scan using the latest Docker image
    - name: Run Gitleaks
      run: |
        echo "Running Gitleaks scan..."
        docker run --rm -v $GITHUB_WORKSPACE:/workspace zricethezav/gitleaks:latest detect --source /workspace --report-format json --report-path /workspace/gitleaks_results.json || true

    # Check Gitleaks results for vulnerabilities
    - name: Check Gitleaks results
      run: |
        if grep -q '"StartLine":' gitleaks_results.json; then
          echo "Vulnerabilities found by Gitleaks"
          exit 1
        fi

    # Upload Gitleaks results as an artifact
    - name: Upload Gitleaks results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: gitleaks-results
        path: gitleaks_results.json

  semgrep:
    runs-on: ubuntu-latest

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v3

    # Run Semgrep scan using the latest Docker image
    - name: Scan with Semgrep
      run: |
        echo "Running Semgrep scan..."
        docker run --rm -v $GITHUB_WORKSPACE:/src returntocorp/semgrep:latest semgrep --config=semgrep-rules.yml --json > semgrep_results.json || true

    # Check Semgrep results for vulnerabilities
    - name: Check Semgrep results
      run: |
        if grep -q '"extra":' semgrep_results.json; then
          echo "Vulnerabilities found by Semgrep"
          exit 1
        fi

    # Upload Semgrep results as an artifact
    - name: Upload Semgrep results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: semgrep-results
        path: semgrep_results.json

    # Post Semgrep results as a comment on the pull request
    - name: Post Semgrep results as a comment
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let results;
          try {
            results = JSON.parse(fs.readFileSync('semgrep_results.json', 'utf8'));
          } catch (error) {
            console.error('Error parsing Semgrep results:', error);
            return;
          }

          let commentBody = '## Semgrep Scan Results\n\n';
          if (results.results && results.results.length > 0) {
            results.results.forEach(result => {
              commentBody += `### ${result.check_id}\n`;
              commentBody += `**Reason:** ${result.extra.message}\n\n`;
              commentBody += `**File:** ${result.path}\n`;
              commentBody += `**Line:** ${result.start.line}\n\n`;
            });
          } else {
            commentBody += 'No vulnerabilities found.';
          }

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: commentBody
          });

  defectdojo:
    runs-on: ubuntu-latest
    needs: [gitleaks, semgrep]
    if: always()

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v2

    # Download Gitleaks results artifact
    - name: Download Gitleaks results
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: gitleaks-results
        path: .

    # Download Semgrep results artifact
    - name: Download Semgrep results
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: semgrep-results
        path: .

    # Upload Gitleaks results to DefectDojo
    - name: Upload Gitleaks results to DefectDojo
      run: |
        if [ -f gitleaks_results.json ]; then
          echo "Uploading Gitleaks results to DefectDojo..."
          response=$(curl -X POST "$DEFECTDOJO_URL/api/v2/import-scan/" \
          -H "Authorization: Token $DEFECTDOJO_API_KEY" \
          -H "Content-Type: multipart/form-data" \
          -F "file=@gitleaks_results.json" \
          -F "scan_type=Gitleaks Scan" \
          -F "engagement=$DEFECTDOJO_ENGAGEMENT_ID" -w "\n%{http_code}")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "HTTP Status Code: $http_code"
          echo "Response Body: $body"
          if [ "$http_code" -ne 201 ]; then
            echo "Failed to upload Gitleaks results"
            exit 1
          fi
        else
          echo "Gitleaks results not found."
        fi

    # Upload Semgrep results to DefectDojo
    - name: Upload Semgrep results to DefectDojo
      run: |
        if [ -f semgrep_results.json ]; then
          echo "Uploading Semgrep results to DefectDojo..."
          response=$(curl -X POST "$DEFECTDOJO_URL/api/v2/import-scan/" \
          -H "Authorization: Token $DEFECTDOJO_API_KEY" \
          -H "Content-Type: multipart/form-data" \
          -F "file=@semgrep_results.json" \
          -F "scan_type=Semgrep JSON Report" \
          -F "engagement=$DEFECTDOJO_ENGAGEMENT_ID" -w "\n%{http_code}")
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          echo "HTTP Status Code: $http_code"
          echo "Response Body: $body"
          if [ "$http_code" -ne 201 ]; then
            echo "Failed to upload Semgrep results"
            exit 1
          fi
        else
          echo "Semgrep results not found."
        fi

  build:
    runs-on: ubuntu-latest
    needs: [defectdojo]
    if: ${{ needs.gitleaks.result == 'success' && needs.semgrep.result == 'success' }}

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v2

    # List files for debugging
    - name: List files for debugging
      run: ls -R

    # List files in codegen directory
    - name: List files in codegen directory
      run: ls -R codegen

    # Verify Dockerfile exists
    - name: Verify Dockerfile exists
      run: |
        if [ ! -f codegen/Dockerfile ]; then
          echo "Dockerfile not found!"
          exit 1
        fi

    # Configure AWS Credentials
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # Build, tag, and push docker image to Amazon ECR
    - name: Build, tag, and push docker image to Amazon ECR
      run: |
        IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
        docker build -t $IMAGE_URI -f codegen/Dockerfile codegen
        docker push $IMAGE_URI