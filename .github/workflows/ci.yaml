name: CI Pipeline

on:
  pull_request:
    branches:
      - main

env:
  GITHUB_WORKSPACE: ${{ github.workspace }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

permissions:
  contents: read
  security-events: write
  issues: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v4
      with:
        go-version: '1.20'
    - name: Run tests
      run: |
        cd codegen
        if [ ! -f go.mod ]; then
          go mod init example.com/m
        fi
        go mod tidy
        go test -v ./...

  gitleaks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run Gitleaks
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/workspace zricethezav/gitleaks:latest detect \
          --source /workspace \
          --report-format json \
          --report-path /workspace/gitleaks_results.json
        
        if [ -s gitleaks_results.json ]; then
          echo "::warning::Gitleaks found potential secrets"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let results = [];
          try {
            results = JSON.parse(fs.readFileSync('gitleaks_results.json', 'utf8'));
          } catch (error) {} 
          
          const comment = `## Gitleaks Security Scan Results
          ${results.length ? 'âš ï¸ **Secrets Found**' : 'âœ… **No Secrets Found**'}
          
          ${results.map(r => `
          ### Secret detected in \`${r.File}\`
          - **Location**: Line ${r.StartLine}
          - **Rule Violated**: ${r.Rule}
          - **Description**: ${r.Description || 'Potential secret or credential found'}
          - **Recommendation**: Remove the secret and store it securely in environment variables or a secrets manager
          - **Matched Content**: \`${r.Match}\`
          
          `).join('\n')}
          
          ${results.length ? '### ðŸ”’ Best Practices\n' +
          '- Never commit secrets, credentials or sensitive data\n' +
          '- Use environment variables or secret management tools\n' +
          '- Add sensitive patterns to .gitignore\n' +
          '- Consider using pre-commit hooks to prevent secret commits' : ''}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  semgrep:
    runs-on: ubuntu-latest 
    steps:
    - uses: actions/checkout@v3
    - name: Run Semgrep
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src returntocorp/semgrep:latest \
          semgrep --config=auto \
          --config=p/security-audit \
          --config=p/secrets \
          --config=p/ci \
          --json > semgrep_results.json
        
        if jq -e '.results | length > 0' semgrep_results.json > /dev/null; then
          echo "::warning::Semgrep found security issues"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results  
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let results = {results:[]};
          try {
            results = JSON.parse(fs.readFileSync('semgrep_results.json', 'utf8'));
          } catch (error) {}
          
          const comment = `## Semgrep Security Scan Results
          ${results.results.length ? 'âš ï¸ **Security Issues Found**' : 'âœ… **No Security Issues Found**'}
          
          ${results.results.map(r => `
          ### ${r.check_id}
          - **File**: \`${r.path}\`
          - **Line**: ${r.start.line}
          - **Issue**: ${r.extra.message}
          - **Impact**: ${r.extra.metadata?.impact || 'Potential security vulnerability'}
          - **Confidence**: ${r.extra.metadata?.confidence || 'Unknown'}
          
          **Description**:
          ${r.extra.metadata?.description || r.extra.message}
          
          **Recommendation**:
          ${r.extra.metadata?.fix || 'Review and fix the identified security issue according to best practices'}
          
          `).join('\n')}
          
          ${results.results.length ? '### ðŸ›¡ï¸ Best Practices\n' +
          '- Follow secure coding guidelines\n' +
          '- Implement proper input validation\n' +
          '- Use security-focused code reviews\n' +
          '- Keep security dependencies updated' : ''}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  dependabot:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Get Dependabot alerts
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v4.full+json" \
          "https://api.github.com/repos/${{ github.repository }}/dependabot/alerts")
        
        echo "$response" > dependabot_alerts.json
        
        if echo "$response" | jq -e 'type == "array" and length > 0' > /dev/null; then
          echo "::warning::Found Dependabot security alerts"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results
      if: always() 
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let alerts = [];
          try {
            const content = fs.readFileSync('dependabot_alerts.json', 'utf8');
            alerts = JSON.parse(content);
            if (!Array.isArray(alerts)) alerts = [];
          } catch (error) {}
          
          const comment = `## Dependabot Security Scan Results
          ${alerts.length ? 'âš ï¸ **Vulnerabilities Found**' : 'âœ… **No Vulnerabilities Found**'}
          
          ${alerts.map(alert => `
          ### ${alert.security_advisory?.summary || 'Unknown Vulnerability'}
          - **File**: \`${alert.dependency?.manifest_path || 'Unknown'}\`
          - **Package**: ${alert.dependency?.package?.name || 'Unknown'} (version ${alert.dependency?.version || 'Unknown'})
          - **Severity**: ${alert.security_advisory?.severity || 'Unknown'}
          - **CVSS Score**: ${alert.security_advisory?.cvss?.score || 'N/A'}
          - **Vulnerable Requirements**: ${alert.security_advisory?.vulnerableVersionRange || 'Unknown'}
          
          **Description**:
          ${alert.security_advisory?.description || 'No description available'}
          
          **Recommendation**:
          ${alert.security_advisory?.references?.[0]?.url ? 
          `- Review the advisory: ${alert.security_advisory.references[0].url}
          ` : ''}
          - Update to ${alert.security_advisory?.patched_versions?.[0] || 'the latest version'}
          - Run \`go get -u ${alert.dependency?.package?.name}@latest\`
          
          `).join('\n')}
          
          ${alerts.length ? '### ðŸ“¦ Best Practices\n' +
          '- Regularly update dependencies\n' +
          '- Review security advisories\n' +
          '- Use dependency lockfiles\n' +
          '- Enable automatic security updates' : ''}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  build:
    needs: [test, gitleaks, semgrep, dependabot]
    runs-on: ubuntu-latest
    if: |
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.outputs.SCAN_FAILED, 'true')
    steps:
    - uses: actions/checkout@v3
    - name: Verify Dockerfile
      run: |
        if [ ! -f codegen/Dockerfile ]; then
          echo "::error::Dockerfile not found!"
          exit 1
        fi
    - uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    - uses: aws-actions/amazon-ecr-login@v2
      id: login-ecr
    - name: Build and push
      run: |
        IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
        docker build -t $IMAGE_URI -f codegen/Dockerfile codegen
        docker push $IMAGE_URI