name: CI Pipeline

on:
  pull_request:
    branches:
      - main

env:
  GITHUB_WORKSPACE: ${{ github.workspace }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

permissions:
  contents: read
  security-events: write
  issues: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v4
      with:
        go-version: '1.20'
    - name: Run tests
      run: |
        cd codegen
        if [ ! -f go.mod ]; then
          go mod init example.com/m
        fi
        go mod tidy
        go test -v ./...

  gitleaks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run Gitleaks
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/workspace zricethezav/gitleaks:latest detect \
          --source /workspace \
          --report-format json \
          --report-path /workspace/gitleaks_results.json
        
        if [ -s gitleaks_results.json ]; then
          echo "::warning::Gitleaks found potential secrets"
          cat gitleaks_results.json
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let results = [];
          try {
            results = JSON.parse(fs.readFileSync('gitleaks_results.json', 'utf8'));
          } catch (error) {} 
          
          const comment = `## Gitleaks Scan Results
          ${results.length ? '⚠️ **Secrets Found**' : '✅ **No Secrets Found**'}
          
          ${results.map(r => (
            `- **${r.Rule}** in \`${r.File}\` (line ${r.StartLine})`
          )).join('\n')}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  semgrep:
    runs-on: ubuntu-latest 
    steps:
    - uses: actions/checkout@v3
    - name: Run Semgrep
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src returntocorp/semgrep:latest \
          semgrep --config=auto \
          --config=p/security-audit \
          --config=p/secrets \
          --config=p/ci \
          --json > semgrep_results.json
        
        if jq -e '.results | length > 0' semgrep_results.json > /dev/null; then
          echo "::warning::Semgrep found security issues"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results  
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let results = {results:[]};
          try {
            results = JSON.parse(fs.readFileSync('semgrep_results.json', 'utf8'));
          } catch (error) {}
          
          const comment = `## Semgrep Scan Results
          ${results.results.length ? '⚠️ **Security Issues Found**' : '✅ **No Security Issues Found**'}
          
          ${results.results.map(r => (
            `### ${r.check_id}
            - File: \`${r.path}\`
            - Line: ${r.start.line}
            - ${r.extra.message}`
          )).join('\n\n')}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  dependabot:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Get Dependabot alerts
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v4.full+json" \
          "https://api.github.com/repos/${{ github.repository }}/dependabot/alerts")
        
        echo "$response" > dependabot_alerts.json
        
        if echo "$response" | jq -e 'type == "array" and length > 0' > /dev/null; then
          echo "::warning::Found Dependabot security alerts"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results
      if: always() 
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let alerts = [];
          try {
            const content = fs.readFileSync('dependabot_alerts.json', 'utf8');
            alerts = JSON.parse(content);
            if (!Array.isArray(alerts)) alerts = [];
          } catch (error) {}
          
          const comment = `## Dependabot Security Scan
          ${alerts.length ? '⚠️ **Vulnerabilities Found**' : '✅ **No Vulnerabilities Found**'}
          
          ${alerts.map(alert => (
            `### ${alert.security_advisory?.summary || 'Unknown Issue'}
            - Severity: ${alert.security_advisory?.severity || 'Unknown'}
            - Package: ${alert.dependency?.package?.name || 'Unknown'}
            - Version: ${alert.dependency?.version || 'Unknown'}
            - Path: ${alert.dependency?.manifest_path || 'Unknown'}`
          )).join('\n\n')}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  build:
    needs: [test, gitleaks, semgrep, dependabot]
    runs-on: ubuntu-latest
    if: |
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.outputs.SCAN_FAILED, 'true')
    steps:
    - uses: actions/checkout@v3
    - name: Verify Dockerfile
      run: |
        if [ ! -f codegen/Dockerfile ]; then
          echo "::error::Dockerfile not found!"
          exit 1
        fi
    - uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    - uses: aws-actions/amazon-ecr-login@v2
      id: login-ecr
    - name: Build and push
      run: |
        IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
        docker build -t $IMAGE_URI -f codegen/Dockerfile codegen
        docker push $IMAGE_URI