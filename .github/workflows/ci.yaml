name: CI Pipeline

on:
  pull_request:
    branches:
      - main

env:
  GITHUB_WORKSPACE: ${{ github.workspace }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}
  CODEGEN_DIR: codegen

permissions:
  contents: read
  security-events: write
  issues: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v4
      with:
        go-version: '1.20'
    - name: Run tests
      working-directory: ${{ env.CODEGEN_DIR }}
      run: |
        if [ ! -f go.mod ]; then
          go mod init example.com/m
        fi
        go mod tidy
        go test -v ./...

  gitleaks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run Gitleaks
      run: |
        docker run --rm -v ${{ github.workspace }}:/workspace zricethezav/gitleaks:latest detect \
          --source /workspace/codegen \
          --report-format json \
          --report-path /workspace/gitleaks_results.json
        
        if [ -s gitleaks_results.json ]; then
          echo "::warning::Gitleaks found potential secrets"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
        fi
    - name: Post results
      if: always()
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          let results = [];
          try {
            results = JSON.parse(fs.readFileSync('gitleaks_results.json', 'utf8'));
          } catch (error) {} 
          
          const comment = `## Gitleaks Security Scan Results
          ${results.length ? '‚ö†Ô∏è **Secrets Found**' : '‚úÖ **No Secrets Found**'}
          
          ${results.map(r => `
          ### Secret detected in \`${r.File}\`
          - **Location**: Line ${r.StartLine}
          - **Rule Violated**: ${r.Rule}
          - **Description**: ${r.Description || 'Potential secret or credential found'}
          - **Recommendation**: Remove the secret and store it securely in environment variables or a secrets manager
          - **Matched Content**: \`${r.Match}\`
          
          `).join('\n')}
          
          ${results.length ? '### üîí Best Practices\n' +
          '- Never commit secrets, credentials or sensitive data\n' +
          '- Use environment variables or secret management tools\n' +
          '- Add sensitive patterns to .gitignore\n' +
          '- Consider using pre-commit hooks to prevent secret commits' : ''}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  semgrep:
    runs-on: ubuntu-latest 
    steps:
    - uses: actions/checkout@v3
    - name: Run Semgrep
      id: scan
      run: |
        docker run --rm -v ${{ github.workspace }}:/src returntocorp/semgrep:latest \
          semgrep scan \
          --config=auto \
          --config=p/security-audit \
          --config=p/secrets \
          --config=p/ci \
          --include="codegen/**/*.go" \
          --include="codegen/go.mod" \
          --include="codegen/go.sum" \
          --json > semgrep_results.json
        
        if jq -e '.results | length > 0' semgrep_results.json > /dev/null; then
          echo "::error::Semgrep found security issues"
          echo "SCAN_FAILED=true" >> $GITHUB_ENV
          exit 1
        fi
    - name: Post results  
      if: always()
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          let results = {results:[]};
          try {
            results = JSON.parse(fs.readFileSync('semgrep_results.json', 'utf8'));
          } catch (error) {}
          
          const comment = `## Semgrep Security Scan Results
          ${results.results.length ? '‚ö†Ô∏è **Security Issues Found**' : '‚úÖ **No Security Issues Found**'}
          
          ${results.results.map(r => `
          ### ${r.check_id}
          - **File**: \`${r.path}\`
          - **Line**: ${r.start.line}
          - **Issue**: ${r.extra.message}
          - **Impact**: ${r.extra.metadata?.impact || 'Potential security vulnerability'}
          - **Confidence**: ${r.extra.metadata?.confidence || 'Unknown'}
          
          **Description**:
          ${r.extra.metadata?.description || r.extra.message}
          
          **Recommendation**:
          ${r.extra.metadata?.fix || 'Review and fix the identified security issue according to best practices'}
          
          `).join('\n')}
          
          ${results.results.length ? '### üõ°Ô∏è Best Practices\n' +
          '- Follow secure coding guidelines\n' +
          '- Implement proper input validation\n' +
          '- Use security-focused code reviews\n' +
          '- Keep security dependencies updated' : ''}`;
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: comment
          });

  dependabot:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v4
      with:
        go-version: '1.20'
    - name: Get Security Alerts
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        response=$(curl -s \
          -H "Accept: application/vnd.github.v4+json" \
          -H "Authorization: Bearer $GH_TOKEN" \
          "https://api.github.com/repos/${{ github.repository }}/vulnerability-alerts")
        
        if echo "$response" | jq -e 'has("message")' > /dev/null; then
          message=$(echo "$response" | jq -r '.message')
          echo "::warning::API Response: $message"
          if [[ "$message" == "Resource not accessible by integration" ]]; then
            echo "DEPENDABOT_ERROR=true" >> $GITHUB_ENV
          fi
          echo "[]" > dependabot_alerts.json
        else
          echo "$response" > dependabot_alerts.json
          
          if echo "$response" | jq -e 'length > 0' > /dev/null; then
            echo "::warning::Found vulnerability alerts"
            echo "SCAN_FAILED=true" >> $GITHUB_ENV
          fi
        fi
    - name: Analyze dependencies
      working-directory: ${{ env.CODEGEN_DIR }}
      run: |
        if [ ! -f go.mod ]; then
          go mod init example.com/m
        fi
        go mod tidy
        go mod download
        go list -json -m all > ../go_modules.json
    - name: Post results
      if: always()
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          let alerts = [];
          let modules = {};
          let dependabotError = process.env.DEPENDABOT_ERROR === 'true';
          
          try {
            const content = fs.readFileSync('dependabot_alerts.json', 'utf8');
            alerts = JSON.parse(content);
            if (!Array.isArray(alerts)) alerts = [];
            
            const modulesContent = fs.readFileSync('go_modules.json', 'utf8');
            modules = JSON.parse(modulesContent);
          } catch (error) {
            console.error('Error parsing results:', error);
          }
          
          let commentBody = '## Dependabot Security Scan Results\n\n';
          
          if (dependabotError) {
            commentBody += '‚ö†Ô∏è **Error: Resource not accessible by integration**\n\n';
            commentBody += 'The Dependabot scan could not access the necessary resources. Please ensure that Dependabot has the required permissions and try again.\n\n';
          } else if (alerts.length > 0) {
            commentBody += '‚ö†Ô∏è **Vulnerabilities Found**\n\n';
            alerts.forEach(alert => {
              commentBody += `### ${alert.security_advisory?.summary || 'Unknown Vulnerability'}\n`;
              commentBody += `- **Severity**: ${alert.security_advisory?.severity || 'Unknown'}\n`;
              commentBody += `- **Package**: ${alert.dependency?.package?.name || 'Unknown'} (version ${alert.dependency?.version || 'Unknown'})\n`;
              commentBody += `- **Vulnerable Requirements**: ${alert.security_advisory?.vulnerableVersionRange || 'Unknown'}\n\n`;
              commentBody += `**Description**: ${alert.security_advisory?.description || 'No description available'}\n\n`;
              commentBody += `**Recommendation**: Update to ${alert.security_advisory?.patched_versions?.[0] || 'the latest version'}\n\n`;
            });
          } else {
            commentBody += '‚úÖ **No Vulnerabilities Found**\n\n';
          }
          
          commentBody += '### üì¶ Current Dependencies\n';
          commentBody += modules.Deps ? `Found ${modules.Deps.length} dependencies\n` : 'No dependency information available\n';
          
          commentBody += '\n### üõ°Ô∏è Best Practices\n';
          commentBody += '- Regularly update dependencies\n';
          commentBody += '- Review security advisories\n';
          commentBody += '- Use dependency lockfiles\n';
          commentBody += '- Enable Dependabot security updates\n';
          commentBody += '- Set up automated dependency updates\n';
          
          await github.rest.issues.createComment({
            ...context.repo,
            issue_number: context.issue.number,
            body: commentBody
          });

  build:
    needs: [test, gitleaks, semgrep, dependabot]
    runs-on: ubuntu-latest
    if: |
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.outputs.SCAN_FAILED, 'true')
    steps:
    - uses: actions/checkout@v3
    - name: Verify Dockerfile
      run: |
        if [ ! -f ${{ env.CODEGEN_DIR }}/Dockerfile ]; then
          echo "::error::Dockerfile not found in ${{ env.CODEGEN_DIR }}!"
          exit 1
        fi
    - uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    - uses: aws-actions/amazon-ecr-login@v2
      id: login-ecr
    - name: Build and push
      run: |
        IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
        docker build -t $IMAGE_URI -f ${{ env.CODEGEN_DIR }}/Dockerfile ${{ env.CODEGEN_DIR }}
        docker push $IMAGE_URI
